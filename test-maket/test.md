# Погружение в недра. Разбираем kernel exploitation, чтобы добраться до рута на виртуалке c Hack The Box
![preview](./Rectangle1.jpg)


В этой статье будем раз­бирать одну из самых слож­ных тем в сфе­ре PWN — эксплуата­цию ядра Linux. Ты узна­ешь, какие инс­тру­мен­ты при­меня­ются для отладки ядра, что такое LKM, KGDB, IOCTL, TTY, и мно­го дру­гих инте­рес­ных вещей!

В стать­ях **«Раз­бира­ем V8»** и **«Ку­ча прик­лючений»** мы про­ложи­ли себе путь к пользователю r4j на хардкор­ной вир­туал­ке RopeTwo. Что­бы доб­рать­ся до рута, оста­ется пос­ледний шаг, но какой! Нас ждет ROP (не зря же вир­туал­ку так наз­вали) и kernel exploitation. Моз­ги будут закипать, обе­щаю! Запасай­ся поп­корном дебаг­гером и поехали!

## РАЗВЕДКА

Как и в слу­чае с фла­гом поль­зовате­ля из пре­дыду­щей статьи, пер­вым делом запус­каем LinPEAS и вни­матель­но смот­рим, за что мож­но зацепить­ся. В гла­за бро­сают­ся две подоз­ритель­ные строч­ки:

```js
[+] Looking for Signature verification failed in dmseg
[   13.882339] ralloc: module verification failed: signature and/or required key missing - tainting kernel
--
[+] Readable files belonging to root and readable by me but not world readable
-rw-r----- 1 root r4j 5856 Jun  1  2020 /usr/lib/modules/5.0.0-38-generic/kernel/drivers/ralloc/ralloc.ko
```

Ви­дим, что в сис­теме от поль­зовате­ля root заг­ружен непод­писан­ный модуль ядра, дос­тупный нам для чте­ния. А это зна­чит, что впе­реди kernel exploitation!

## СТАТИЧЕСКИЙ АНАЛИЗ

Пер­вое, что нам нуж­но, — это ска­чать себе ralloc.ko и нат­равить на него «Гид­ру».

Ви­дим, что ralloc — это LKM, который выпол­няет раз­личные опе­рации с памятью при получе­нии сис­темных вызовов ioctl. По сути, это самопис­ный драй­вер управле­ния памятью (Superfast memory allocator, как опи­сыва­ет его сам автор), оче­вид­но, что не без уяз­вимос­тей.

LKM (loadable kernel module) — объ­ектный файл, содер­жащий код, который рас­ширя­ет воз­можнос­ти ядра опе­раци­онной сис­темы. В нем реали­зова­ны все­го четыре фун­кции:

1. вы­деле­ние памяти в адресном прос­транс­тве ядра (kmalloc) — вызов ioctl 0x1000;
2. очи­щение памяти в адресном прос­транс­тве ядра (kfree) — вызов ioctl 0x1001;
3. ко­пиро­вание информа­ции из адресно­го прос­транс­тва поль­зовате­ля в прос­транс­тво ядра (memcpy(kernel_addr, user_addr, size)) — вызов ioctl 0x1002;
4. ко­пиро­вание информа­ции из адресно­го прос­транс­тва ядра в прос­транс­тво поль­зовате­ля (memcpy(user_addr, kernel_addr, size)) — вызов ioctl 0x1003.

Ни­же дизас­сем­бли­рован­ный и при­веден­ный в чита­емый вид лис­тинг этих фун­кций:

```js
case 0x1000:    // Функция выделения памяти ядра
  if ((size < 0x401) && (idx < 0x20)) {
    if (arr[idx].size== 0) {
      ptr = __kmalloc(size, 0x6000c0);
      arr[idx].data = ptr;
      if (ptr != 0) {
        arr[idx].size = size_alloc + 0x20;
        return_value = 0;
      }
    }
  }
  break;
case 0x1001:    // Функция освобождения памяти ядра
  if ((idx < 0x20) && arr[idx].data != 0)) {
      kfree(arr[idx].ptr);
      arr[idx].size = 0;
      return_value = 0;
    }
  break;
```

Пос­мотри вни­матель­но на лис­тинг. Воз­можно, ты най­дешь уяз­вимость, она поч­ти сра­зу бро­сает­ся в гла­за! А пока зай­мем­ся под­готов­кой стен­да.

## РАЗВОРАЧИВАЕМ СТЕНД

![img](./Rectangle2.png)

Оче­вид­но, что для отладки ядра нам понадо­бит­ся вир­туаль­ная машина. Да не одна, а целых две! Одна сыг­рает роль хос­та, где уста­нов­лено ядро с отла­доч­ными сим­волами и где мы при­меним отладчик GDB, вто­рая будет запус­кать­ся в режиме KGDB (отладчик ядра Linux). Связь меж­ду вир­туаль­ными машина­ми уста­нав­лива­ется либо по пос­ледова­тель­ному пор­ту, либо по локаль­ной сети. Схе­матич­но это выг­лядит так.
Supervisor mode execution protection (SMEP) и supervisor mode access prevention (SMAP) — фун­кции безопас­ности, которые исполь­зуют­ся в пос­ледних поколе­ниях CPU. SMEP пре­дот­вра­щает исполне­ние кода из режима ядра в адресном прос­транс­тве поль­зовате­ля, SMAP — неп­редна­мерен­ный дос­туп из режима ядра в адресное прос­транс­тво поль­зовате­ля. Эти опции кон­тро­лиру­ются вклю­чени­ем опре­делен­ных битов в регис­тре CR4. Под­робнее об этом мож­но почитать в докумен­тации Intel (PDF).
Так­же вклю­чен KASLR — это умол­чатель­ный вари­ант в новых вер­сиях ядра Linux.



